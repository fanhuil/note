# 1 String（字符串）

<img src="%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/3d26389447e37c5d7ea94fb7a32dd677.png" alt="img" style="zoom:67%;" />

## SET

```bash
SET key value [EX seconds] [PX milliseconds] [NX|XX]
```

> 将字符串值 `value` 关联到 `key` 。
>
> 如果 `key` 已经持有其他值， [SET](http://doc.redisfans.com/string/set.html#set) 就覆写旧值，无视类型。
>
> 对于某个原本带有生存时间（TTL）的键来说， 当 [*SET*](http://doc.redisfans.com/string/set.html#set) 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。
>
> **可选参数**
>
> 从 Redis 2.6.12 版本开始， [*SET*](http://doc.redisfans.com/string/set.html#set) 命令的行为可以通过一系列参数来修改：
>
> - `EX second` ：设置键的过期时间为 `second` 秒。 `SET key value EX second` 效果等同于 `SETEX key second value` 。
> - `PX millisecond` ：设置键的过期时间为 `millisecond` 毫秒。 `SET key value PX millisecond` 效果等同于 `PSETEX key millisecond value` 。
> - `NX` ：只在键不存在时，才对键进行设置操作。 `SET key value NX` 效果等同于 `SETNX key value` 。
> - `XX` ：只在键已经存在时，才对键进行设置操作。

> 因为 [*SET*](http://doc.redisfans.com/string/set.html#set) 命令可以通过参数来实现和 [*SETNX*](http://doc.redisfans.com/string/setnx.html#setnx) 、 [*SETEX*](http://doc.redisfans.com/string/setex.html#setex) 和 [*PSETEX*](http://doc.redisfans.com/string/psetex.html#psetex) 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 [*SETNX*](http://doc.redisfans.com/string/setnx.html#setnx) 、 [*SETEX*](http://doc.redisfans.com/string/setex.html#setex) 和 [*PSETEX*](http://doc.redisfans.com/string/psetex.html#psetex) 这三个命令。



# 2 Hash（哈希表）

<img src="%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/4601c15335152ee4c05a3d91dc55b284.png" alt="img" style="zoom:67%;" />

## HSET

```bash
HSET key field value
```

> 将哈希表 `key` 中的域 `field` 的值设为 `value` 。
>
> 如果 `key` 不存在，一个新的哈希表被创建并进行 [HSET](http://doc.redisfans.com/hash/hset.html#hset) 操作。
>
> 如果域 `field` 已经存在于哈希表中，旧值将被覆盖。



# 3 List（列表）

<img src="%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/25ab3f778a150d0b226f083af128af3b.png" alt="img" style="zoom: 67%;" />

## LPUSH

```bash
LPUSH key value [value ...]
```

> 将一个或多个值 `value` 插入到列表 `key` 的表头
>
> 如果有多个 `value` 值，那么各个 `value` 值按从左到右的顺序依次插入到表头： 比如说，对空列表 `mylist` 执行命令 `LPUSH mylist a b c` ，列表的值将是 `c b a` ，这等同于原子性地执行 `LPUSH mylist a` 、 `LPUSH mylist b` 和 `LPUSH mylist c` 三个命令。
>
> 如果 `key` 不存在，一个空列表会被创建并执行 [LPUSH](http://doc.redisfans.com/list/lpush.html#lpush) 操作。
>
> 当 `key` 存在但不是列表类型时，返回一个错误。

> 在Redis 2.4版本以前的 [LPUSH](http://doc.redisfans.com/list/lpush.html#lpush) 命令，都只接受单个 `value` 值。

## RPUSH

```bash
RPUSH key value [value ...]
```

> 将一个或多个值 `value` 插入到列表 `key` 的表尾(最右边)。
>
> 如果有多个 `value` 值，那么各个 `value` 值按从左到右的顺序依次插入到表尾：比如对一个空列表 `mylist` 执行 `RPUSH mylist a b c` ，得出的结果列表为 `a b c` ，等同于执行命令 `RPUSH mylist a` 、 `RPUSH mylist b` 、 `RPUSH mylist c` 。
>
> 如果 `key` 不存在，一个空列表会被创建并执行 [RPUSH](http://doc.redisfans.com/list/rpush.html#rpush) 操作。
>
> 当 `key` 存在但不是列表类型时，返回一个错误。

> 在 Redis 2.4 版本以前的 [RPUSH](http://doc.redisfans.com/list/rpush.html#rpush) 命令，都只接受单个 `value` 值。



# 4 Set（集合）

<img src="%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/b80125277c7cf5a5009553513f3c9568.png" alt="img" style="zoom:67%;" />

## SADD

```bash
SADD key member [member ...]
```

> 将一个或多个 `member` 元素加入到集合 `key` 当中，已经存在于集合的 `member` 元素将被忽略。
>
> 假如 `key` 不存在，则创建一个只包含 `member` 元素作成员的集合。
>
> 当 `key` 不是集合类型时，返回一个错误。

> 在Redis2.4版本以前， [SADD](http://doc.redisfans.com/set/sadd.html#sadd) 只接受单个 `member` 值。



# 5 SortedSet（有序集合）

<img src="%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/25ab3f778a150d0b226f083af128af3b.png" alt="img" style="zoom:67%;" />

## ZADD

```bash
ZADD key score member [[score member] [score member] ...]
```

> 将一个或多个 `member` 元素及其 `score` 值加入到有序集 `key` 当中。
>
> 如果某个 `member` 已经是有序集的成员，那么更新这个 `member` 的 `score` 值，并通过重新插入这个 `member` 元素，来保证该 `member` 在正确的位置上。
>
> `score` 值可以是整数值或双精度浮点数。
>
> 如果 `key` 不存在，则创建一个空的有序集并执行 [ZADD](http://doc.redisfans.com/sorted_set/zadd.html#zadd) 操作。
>
> 当 `key` 存在但不是有序集类型时，返回一个错误。
>
> 对有序集的更多介绍请参见 [sorted set](http://redis.io/topics/data-types#sorted-sets) 。

> 在 Redis 2.4 版本以前， [ZADD](http://doc.redisfans.com/sorted_set/zadd.html#zadd) 每次只能添加一个元素。



------

# Key（键）

## DEL

```bash
DEL key [key ...]
```

> 删除给定的一个或多个 `key` 。
>
> 不存在的 `key` 会被忽略。

## EXPIRE

```bash
EXPIRE key seconds
```

> 为给定 `key` 设置生存时间，当 `key` 过期时(生存时间为 `0` )，它会被自动删除。
>
> 在 Redis 中，带有生存时间的 `key` 被称为『易失的』(volatile)。
>
> 生存时间可以通过使用 [*DEL*](http://doc.redisfans.com/key/del.html#del) 命令来删除整个 `key` 来移除，或者被 [*SET*](http://doc.redisfans.com/string/set.html#set) 和 [*GETSET*](http://doc.redisfans.com/string/getset.html#getset) 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 `key` 的值而不是用一个新的 `key` 值来代替(replace)它的话，那么生存时间不会被改变。
>
> 比如说，对一个 `key` 执行 [*INCR*](http://doc.redisfans.com/string/incr.html#incr) 命令，对一个列表进行 [*LPUSH*](http://doc.redisfans.com/list/lpush.html#lpush) 命令，或者对一个哈希表执行 [*HSET*](http://doc.redisfans.com/hash/hset.html#hset) 命令，这类操作都不会修改 `key` 本身的生存时间。
>
> 另一方面，如果使用 [*RENAME*](http://doc.redisfans.com/key/rename.html) 对一个 `key` 进行改名，那么改名后的 `key` 的生存时间和改名前一样。
>
> [*RENAME*](http://doc.redisfans.com/key/rename.html) 命令的另一种可能是，尝试将一个带生存时间的 `key` 改名成另一个带生存时间的 `another_key` ，这时旧的 `another_key` (以及它的生存时间)会被删除，然后旧的 `key` 会改名为 `another_key` ，因此，新的 `another_key` 的生存时间也和原本的 `key` 一样。
>
> 使用 [*PERSIST*](http://doc.redisfans.com/key/persist.html) 命令可以在不删除 `key` 的情况下，移除 `key` 的生存时间，让 `key` 重新成为一个『持久的』(persistent) `key` 。
>
> **更新生存时间**
>
> 可以对一个已经带有生存时间的 `key` 执行 [*EXPIRE*](http://doc.redisfans.com/key/expire.html#expire) 命令，新指定的生存时间会取代旧的生存时间。
>
> **过期时间的精确度**
>
> 在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 `key` 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。
>
> **Redis 2.1.3 之前的不同之处**
>
> 在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 `key` 会导致整个 `key` 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。

## EXISTS

```bash
EXISTS key
```

> 检查给定 `key` 是否存在。

## KEYS

> 查看key的值

```bash
KEYS pattern
```

> 查找所有符合给定模式 `pattern` 的 `key` 。
>
> `KEYS *` 匹配数据库中所有 `key` 。
>
> `KEYS h?llo` 匹配 `hello` ， `hallo` 和 `hxllo` 等。
>
> `KEYS h*llo` 匹配 `hllo` 和 `heeeeello` 等。
>
> `KEYS h[ae]llo` 匹配 `hello` 和 `hallo` ，但不匹配 `hillo` 。
>
> 特殊符号用 `\` 隔开

> [KEYS](http://doc.redisfans.com/key/keys.html#keys) 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 `key` ，你最好还是用 Redis 的集合结构(set)来代替。



# 其它命令

## select

> 选择数据库

```bash
select index
```



## 验证权限

> 操作redis需要验证auth

```bash
auth password
```



## type

> 查看key的类型

```bash
type key
```



